use std::collections::BTreeMap;

use specta::{
    export::get_types,
    ts::{self, ExportConfig},
    DataType, TypeMap,
};

use crate::service::{RouteType, Service};

pub fn generate_typescript<Ctx>(conf: &ExportConfig, service: &Service<Ctx>) -> String
where
    Ctx: Send + Sync + 'static,
{
    let mut out =
        format!("// This file has been generated by Hyperschema, using Specta. DO NOT EDIT.\n\n");

    // We sort by name to detect duplicate types BUT also to ensure the output is deterministic.
    // The SID can change between builds so is not suitable for this.
    let types = get_types().collect::<BTreeMap<_, _>>();

    // This is a clone of `detect_duplicate_type_names`but using a `BTreeMap` for deterministic ordering
    let mut map = BTreeMap::new();
    for (sid, dt) in &types {
        if let Some(ext) = &dt.ext() {
            if let Some((existing_sid, _)) =
                map.insert(dt.name().clone(), (sid, ext.impl_location()))
            {
                if existing_sid != sid {
                    panic!("duplicate type name")
                    // return Err(ExportError::DuplicateTypeName(
                    //     dt.name().clone(),
                    //     ext.impl_location(),
                    //     existing_impl_location,
                    // ));
                }
            }
        }
    }

    let mut type_map = TypeMap::default();
    for (sid, dt) in types.iter() {
        type_map.insert(*sid, dt.clone())
    }
    for (_, typ) in types.iter() {
        out += &specta::ts::export_named_datatype(conf, typ, &type_map).unwrap();
        out += "\n\n";
    }

    // dbg!(&service.type_map.len());
    service.queries.iter().for_each(|(_, route)| {
        dbg!(route_type_to_ts(conf, &service.type_map, &route.ty));

        out += "\n\n";
    });
    out
}

// fn datatype_to_name(datatype: &DataType) -> String {
//     match datatype {
//         DataType::Primitive(p) => p.to_string(),
//     }
// }

fn route_type_to_ts(conf: &ExportConfig, type_map: &TypeMap, route_type: &RouteType) -> String {
    match route_type {
        RouteType::Query(arg, res) => {
            format!(
                "export type Query<Arg = {}, Res = {}> = (arg: Arg) => Promise<Res>;",
                ts::datatype(conf, arg, type_map).unwrap(),
                ts::datatype(conf, res, type_map).unwrap()
            )
        }
    }
}
