use std::collections::BTreeMap;

use specta::{export::get_types, ts::ExportConfig, TypeMap};

use crate::service::Service;

pub fn generate_typescript<Ctx>(conf: &ExportConfig, service: &Service<Ctx>) -> String
where
    Ctx: Send + Sync + 'static,
{
    let mut out =
        format!("// This file has been generated by Hyperschema, using Specta. DO NOT EDIT.\n\n");

    // We sort by name to detect duplicate types BUT also to ensure the output is deterministic.
    // The SID can change between builds so is not suitable for this.
    let types = get_types().collect::<BTreeMap<_, _>>();

    // This is a clone of `detect_duplicate_type_names`but using a `BTreeMap` for deterministic ordering
    let mut map = BTreeMap::new();
    for (sid, dt) in &types {
        if let Some(ext) = &dt.ext() {
            if let Some((existing_sid, existing_impl_location)) =
                map.insert(dt.name().clone(), (sid, ext.impl_location()))
            {
                if existing_sid != sid {
                    panic!("duplicate type name")
                    // return Err(ExportError::DuplicateTypeName(
                    //     dt.name().clone(),
                    //     ext.impl_location(),
                    //     existing_impl_location,
                    // ));
                }
            }
        }
    }

    let mut type_map = TypeMap::default();
    for (sid, dt) in types.iter() {
        type_map.insert(*sid, dt.clone())
    }
    for (_, typ) in types.iter() {
        out += &specta::ts::export_named_datatype(conf, typ, &type_map).unwrap();
        out += "\n\n";
    }
    out
}
